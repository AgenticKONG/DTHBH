# 黄宾虹数字艺术展3D展厅 - 单元测试用例清单

## 版本
- 版本号: v1.0
- 创建日期: 2026-02-23
- 适用范围: 黄宾虹数字艺术展3D展厅项目

---

## 一、测试概述

### 1.1 测试目标
- 确保代码功能正确
- 提高代码质量
- 降低Bug率
- 支持重构
- 提供代码文档

### 1.2 测试工具
- **测试框架**: Jest
- **Vue测试**: @vue/test-utils
- **断言库**: Jest内置
- **覆盖率工具**: Istanbul

### 1.3 测试覆盖率目标
- **代码覆盖率**: ≥ 70%
- **语句覆盖率**: ≥ 70%
- **分支覆盖率**: ≥ 60%
- **函数覆盖率**: ≥ 80%
- **行覆盖率**: ≥ 70%

---

## 二、3D工具函数测试

### 2.1 几何工具函数测试

#### 测试文件: `three/utils/geometry.spec.js`

#### 测试用例

| 用例ID | 测试用例名称 | 测试内容 | 预期结果 | 优先级 |
|--------|-------------|----------|----------|--------|
| G001 | 计算两点距离 | 测试distance函数计算两点间距离 | 返回正确的距离值 | P0 |
| G002 | 计算三个点角度 | 测试angle函数计算三点间角度 | 返回正确的角度值（弧度） | P0 |
| G003 | 判断点是否在矩形内 | 测试isPointInRect函数 | 正确判断点是否在矩形内 | P0 |
| G004 | 计算矩形中心点 | 测试getRectCenter函数 | 返回正确的中心点坐标 | P0 |
| G005 | 计算矩形对角线长度 | 测试getRectDiagonal函数 | 返回正确的对角线长度 | P1 |
| G006 | 判断两个矩形是否相交 | 测试isRectIntersect函数 | 正确判断矩形相交状态 | P1 |
| G007 | 计算矩形面积 | 测试getRectArea函数 | 返回正确的矩形面积 | P1 |
| G008 | 计算矩形周长 | 测试getRectPerimeter函数 | 返回正确的矩形周长 | P2 |
| G009 | 点到直线的距离 | 测试pointToLineDistance函数 | 返回正确的距离值 | P1 |
| G010 | 判断点是否在圆内 | 测试isPointInCircle函数 | 正确判断点是否在圆内 | P1 |

#### 测试代码示例
```javascript
describe('Geometry Utils', () => {
  describe('distance', () => {
    it('G001: should calculate distance between two points correctly', () => {
      const point1 = { x: 0, y: 0, z: 0 };
      const point2 = { x: 3, y: 4, z: 0 };
      const result = distance(point1, point2);
      expect(result).toBe(5);
    });

    it('G001: should return 0 for same point', () => {
      const point = { x: 1, y: 2, z: 3 };
      const result = distance(point, point);
      expect(result).toBe(0);
    });
  });

  describe('isPointInRect', () => {
    it('G003: should return true for point inside rectangle', () => {
      const point = { x: 5, y: 5 };
      const rect = { x: 0, y: 0, width: 10, height: 10 };
      expect(isPointInRect(point, rect)).toBe(true);
    });

    it('G003: should return false for point outside rectangle', () => {
      const point = { x: 15, y: 15 };
      const rect = { x: 0, y: 0, width: 10, height: 10 };
      expect(isPointInRect(point, rect)).toBe(false);
    });
  });
});
```

---

### 2.2 材质工具函数测试

#### 测试文件: `three/utils/material.spec.js`

#### 测试用例

| 用例ID | 测试用例名称 | 测试内容 | 预期结果 | 优先级 |
|--------|-------------|----------|----------|--------|
| M001 | 创建标准材质 | 测试createStandardMaterial函数 | 返回正确的MeshStandardMaterial | P0 |
| M002 | 创建基础材质 | 测试createBasicMaterial函数 | 返回正确的MeshBasicMaterial | P0 |
| M003 | 创建Phong材质 | 测试createPhongMaterial函数 | 返回正确的MeshPhongMaterial | P0 |
| M004 | 设置材质颜色 | 测试setMaterialColor函数 | 材质颜色设置正确 | P0 |
| M005 | 设置材质粗糙度 | 测试setMaterialRoughness函数 | 材质粗糙度设置正确 | P0 |
| M006 | 设置材质金属度 | 测试setMaterialMetalness函数 | 材质金属度设置正确 | P0 |
| M007 | 设置材质透明度 | 测试setMaterialOpacity函数 | 材质透明度设置正确 | P0 |
| M008 | 克隆材质 | 测试cloneMaterial函数 | 返回材质的独立副本 | P1 |
| M009 | 合并材质 | 测试mergeMaterials函数 | 正确合并材质属性 | P1 |
| M010 | 释放材质资源 | 测试disposeMaterial函数 | 材质资源正确释放 | P0 |

#### 测试代码示例
```javascript
describe('Material Utils', () => {
  describe('createStandardMaterial', () => {
    it('M001: should create MeshStandardMaterial with correct properties', () => {
      const config = {
        color: 0xFFFAF0,
        roughness: 0.5,
        metalness: 0.1
      };
      const material = createStandardMaterial(config);

      expect(material).toBeInstanceOf(THREE.MeshStandardMaterial);
      expect(material.color.getHex()).toBe(0xFFFAF0);
      expect(material.roughness).toBe(0.5);
      expect(material.metalness).toBe(0.1);
    });

    it('M001: should throw error when config is invalid', () => {
      expect(() => createStandardMaterial(null)).toThrow();
    });
  });

  describe('disposeMaterial', () => {
    it('M010: should dispose material and its textures', () => {
      const material = new THREE.MeshStandardMaterial({
        map: new THREE.Texture()
      });
      const disposeSpy = jest.spyOn(material, 'dispose');

      disposeMaterial(material);
      expect(disposeSpy).toHaveBeenCalled();
    });
  });
});
```

---

### 2.3 灯光工具函数测试

#### 测试文件: `three/utils/light.spec.js`

#### 测试用例

| 用例ID | 测试用例名称 | 测试内容 | 预期结果 | 优先级 |
|--------|-------------|----------|----------|--------|
| L001 | 创建环境光 | 测试createAmbientLight函数 | 返回正确的AmbientLight | P0 |
| L002 | 创建平行光 | 测试createDirectionalLight函数 | 返回正确的DirectionalLight | P0 |
| L003 | 创建聚光灯 | 测试createSpotLight函数 | 返回正确的SpotLight | P0 |
| L004 | 创建点光源 | 测试createPointLight函数 | 返回正确的PointLight | P0 |
| L005 | 设置灯光颜色 | 测试setLightColor函数 | 灯光颜色设置正确 | P0 |
| L006 | 设置灯光强度 | 测试setLightIntensity函数 | 灯光强度设置正确 | P0 |
| L007 | 设置灯光位置 | 测试setLightPosition函数 | 灯光位置设置正确 | P0 |
| L008 | 启用灯光阴影 | 测试enableLightShadow函数 | 灯光阴影启用成功 | P0 |
| L009 | 设置阴影属性 | 测试setShadowProperties函数 | 阴影属性设置正确 | P1 |
| L010 | 释放灯光资源 | 测试disposeLight函数 | 灯光资源正确释放 | P0 |

#### 测试代码示例
```javascript
describe('Light Utils', () => {
  describe('createSpotLight', () => {
    it('L003: should create SpotLight with correct properties', () => {
      const config = {
        color: 0xffffff,
        intensity: 1.0,
        position: { x: 0, y: 10, z: 0 },
        angle: Math.PI / 6,
        penumbra: 0.5,
        decay: 2,
        distance: 50
      };
      const light = createSpotLight(config);

      expect(light).toBeInstanceOf(THREE.SpotLight);
      expect(light.color.getHex()).toBe(0xffffff);
      expect(light.intensity).toBe(1.0);
      expect(light.position.x).toBe(0);
      expect(light.position.y).toBe(10);
      expect(light.position.z).toBe(0);
    });
  });

  describe('enableLightShadow', () => {
    it('L008: should enable shadow for light', () => {
      const light = new THREE.DirectionalLight();
      enableLightShadow(light);

      expect(light.castShadow).toBe(true);
      expect(light.shadow).toBeDefined();
    });
  });
});
```

---

## 三、场景管理器测试

### 3.1 SceneManager测试

#### 测试文件: `three/scenes/SceneManager.spec.js`

#### 测试用例

| 用例ID | 测试用例名称 | 测试内容 | 预期结果 | 优先级 |
|--------|-------------|----------|----------|--------|
| S001 | 创建场景管理器 | 测试SceneManager构造函数 | 创建成功，初始化正确 | P0 |
| S002 | 初始化场景 | 测试initialize方法 | 场景初始化完成 | P0 |
| S003 | 创建Three.js场景 | 测试createScene方法 | 返回正确的Scene对象 | P0 |
| S004 | 创建相机 | 测试createCamera方法 | 返回正确的Camera对象 | P0 |
| S005 | 创建渲染器 | 测试createRenderer方法 | 返回正确的Renderer对象 | P0 |
| S006 | 添加对象到场景 | 测试addObject方法 | 对象成功添加到场景 | P0 |
| S007 | 从场景移除对象 | 测试removeObject方法 | 对象成功从场景移除 | P0 |
| S008 | 开始渲染循环 | 测试startRender方法 | 渲染循环正常启动 | P0 |
| S009 | 停止渲染循环 | 测试stopRender方法 | 渲染循环正常停止 | P0 |
| S010 | 处理窗口调整 | 测试handleResize方法 | 视口正确调整 | P0 |
| S011 | 销毁场景管理器 | 测试destroy方法 | 资源正确释放 | P0 |
| S012 | 获取当前场景 | 测试getScene方法 | 返回当前Scene对象 | P1 |
| S013 | 获取当前相机 | 测试getCamera方法 | 返回当前Camera对象 | P1 |
| S014 | 获取当前渲染器 | 测试getRenderer方法 | 返回当前Renderer对象 | P1 |
| S015 | 初始化失败处理 | 测试initialize方法异常处理 | 正确抛出错误 | P0 |

#### 测试代码示例
```javascript
describe('SceneManager', () => {
  let manager;
  let container;

  beforeEach(() => {
    container = document.createElement('div');
    document.body.appendChild(container);
    manager = new SceneManager(container);
  });

  afterEach(() => {
    if (manager) {
      manager.destroy();
    }
    document.body.removeChild(container);
  });

  describe('initialize', () => {
    it('S002: should initialize scene successfully', async () => {
      await manager.initialize();

      expect(manager.getScene()).toBeInstanceOf(THREE.Scene);
      expect(manager.getCamera()).toBeInstanceOf(THREE.PerspectiveCamera);
      expect(manager.getRenderer()).toBeInstanceOf(THREE.WebGLRenderer);
    });

    it('S015: should throw error when container is invalid', async () => {
      const invalidManager = new SceneManager(null);
      await expect(invalidManager.initialize()).rejects.toThrow();
    });
  });

  describe('addObject', () => {
    beforeEach(async () => {
      await manager.initialize();
    });

    it('S006: should add object to scene', () => {
      const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1, 1),
        new THREE.MeshBasicMaterial()
      );
      manager.addObject(mesh);

      expect(manager.getScene().children).toContain(mesh);
    });
  });

  describe('destroy', () => {
    beforeEach(async () => {
      await manager.initialize();
      manager.startRender();
    });

    it('S011: should dispose all resources', () => {
      const rendererSpy = jest.spyOn(manager.getRenderer(), 'dispose');
      manager.destroy();

      expect(rendererSpy).toHaveBeenCalled();
      expect(manager.getScene()).toBeNull();
      expect(manager.getCamera()).toBeNull();
      expect(manager.getRenderer()).toBeNull();
    });
  });
});
```

---

### 3.2 HallScene测试

#### 测试文件: `three/scenes/HallScene.spec.js`

#### 测试用例

| 用例ID | 测试用例名称 | 测试内容 | 预期结果 | 优先级 |
|--------|-------------|----------|----------|--------|
| H001 | 创建展厅场景 | 测试HallScene构造函数 | 创建成功，配置正确 | P0 |
| H002 | 加载展厅配置 | 测试loadConfig方法 | 配置加载成功 | P0 |
| H003 | 创建展厅空间 | 测试createSpace方法 | 空间创建成功 | P0 |
| H004 | 创建墙面 | 测试createWalls方法 | 墙面创建成功 | P0 |
| H005 | 创建地面 | 测试createFloor方法 | 地面创建成功 | P0 |
| H006 | 创建顶棚 | 测试createCeiling方法 | 顶棚创建成功 | P0 |
| H007 | 创建展品 | 测试createPaintings方法 | 展品创建成功 | P0 |
| H008 | 创建介绍面板 | 测试createIntros方法 | 介绍面板创建成功 | P0 |
| H009 | 创建灯光 | 测试createLights方法 | 灯光创建成功 | P0 |
| H010 | 创建入口标记 | 测试createEntranceMarkers方法 | 入口标记创建成功 | P0 |
| H011 | 初始化展厅 | 测试initialize方法 | 展厅初始化完成 | P0 |
| H012 | 更新展厅 | 测试update方法 | 展厅更新成功 | P1 |
| H013 | 销毁展厅 | 测试destroy方法 | 展厅资源正确释放 | P0 |
| H014 | 获取展品列表 | 测试getPaintings方法 | 返回正确的展品列表 | P1 |
| H015 | 获取介绍面板列表 | 测试getIntros方法 | 返回正确的介绍面板列表 | P1 |

#### 测试代码示例
```javascript
describe('HallScene', () => {
  let hallScene;
  let sceneManager;

  beforeEach(() => {
    sceneManager = new SceneManager(document.createElement('div'));
    hallScene = new HallScene(sceneManager);
  });

  afterEach(() => {
    if (hallScene) {
      hallScene.destroy();
    }
    if (sceneManager) {
      sceneManager.destroy();
    }
  });

  describe('loadConfig', () => {
    it('H002: should load hall config successfully', () => {
      const config = {
        id: 'early',
        name: '早期展厅',
        space: {
          length: 80,
          width: 16,
          height: 12
        }
      };
      hallScene.loadConfig(config);

      expect(hallScene.config).toEqual(config);
    });

    it('H002: should throw error when config is invalid', () => {
      expect(() => hallScene.loadConfig(null)).toThrow();
    });
  });

  describe('createWalls', () => {
    beforeEach(() => {
      const config = {
        space: { length: 80, width: 16, height: 12 }
      };
      hallScene.loadConfig(config);
    });

    it('H004: should create walls with correct dimensions', () => {
      const walls = hallScene.createWalls();

      expect(walls.length).toBe(4);
      walls.forEach(wall => {
        expect(wall).toBeInstanceOf(THREE.Mesh);
      });
    });
  });

  describe('destroy', () => {
    beforeEach(async () => {
      const config = {
        space: { length: 80, width: 16, height: 12 }
      };
      hallScene.loadConfig(config);
      await hallScene.initialize();
    });

    it('H013: should dispose all hall resources', () => {
      const disposeSpy = jest.spyOn(hallScene, 'cleanup');
      hallScene.destroy();

      expect(disposeSpy).toHaveBeenCalled();
    });
  });
});
```

---

## 四、材质管理器测试

### 4.1 MaterialManager测试

#### 测试文件: `three/materials/MaterialManager.spec.js`

#### 测试用例

| 用例ID | 测试用例名称 | 测试内容 | 预期结果 | 优先级 |
|--------|-------------|----------|----------|--------|
| MM001 | 创建材质管理器 | 测试MaterialManager构造函数 | 创建成功，缓存初始化 | P0 |
| MM002 | 创建材质 | 测试createMaterial方法 | 材质创建成功 | P0 |
| MM003 | 获取材质 | 测试getMaterial方法 | 返回正确的材质 | P0 |
| MM004 | 材质缓存复用 | 测试材质缓存机制 | 相同配置返回同一材质 | P0 |
| MM005 | 创建墙面材质 | 测试createWallMaterial方法 | 返回正确的墙面材质 | P0 |
| MM006 | 创建地面材质 | 测试createFloorMaterial方法 | 返回正确的地面材质 | P0 |
| MM007 | 创建顶棚材质 | 测试createCeilingMaterial方法 | 返回正确的顶棚材质 | P0 |
| MM008 | 创建画框材质 | 测试createFrameMaterial方法 | 返回正确的画框材质 | P0 |
| MM009 | 释放材质 | 测试disposeMaterial方法 | 材质从缓存中移除 | P0 |
| MM010 | 清空材质缓存 | 测试clearCache方法 | 缓存被清空 | P0 |
| MM011 | 获取缓存统计 | 测试getCacheStats方法 | 返回正确的统计信息 | P1 |
| MM012 | 材质配置验证 | 测试材质配置验证 | 无效配置抛出错误 | P0 |

#### 测试代码示例
```javascript
describe('MaterialManager', () => {
  let manager;

  beforeEach(() => {
    manager = new MaterialManager();
  });

  afterEach(() => {
    if (manager) {
      manager.clearCache();
    }
  });

  describe('createMaterial', () => {
    it('MM002: should create material with given config', () => {
      const config = {
        type: 'standard',
        color: 0xFFFAF0,
        roughness: 0.5,
        metalness: 0.1
      };
      const material = manager.createMaterial('wall', config);

      expect(material).toBeInstanceOf(THREE.MeshStandardMaterial);
    });

    it('MM004: should reuse cached material for same config', () => {
      const config = {
        type: 'standard',
        color: 0xFFFAF0,
        roughness: 0.5,
        metalness: 0.1
      };
      const material1 = manager.createMaterial('wall', config);
      const material2 = manager.createMaterial('wall', config);

      expect(material1).toBe(material2);
    });
  });

  describe('getMaterial', () => {
    it('MM003: should return material from cache', () => {
      const config = { type: 'standard', color: 0xFFFAF0 };
      manager.createMaterial('wall', config);
      const material = manager.getMaterial('wall');

      expect(material).toBeDefined();
    });

    it('MM003: should return null for non-existent material', () => {
      const material = manager.getMaterial('non-existent');
      expect(material).toBeNull();
    });
  });

  describe('clearCache', () => {
    it('MM010: should clear all materials from cache', () => {
      manager.createMaterial('wall', { type: 'standard', color: 0xFFFAF0 });
      manager.createMaterial('floor', { type: 'standard', color: 0xF0E6D2 });
      manager.clearCache();

      expect(manager.getMaterial('wall')).toBeNull();
      expect(manager.getMaterial('floor')).toBeNull();
    });
  });
});
```

---

## 五、灯光管理器测试

### 5.1 LightManager测试

#### 测试文件: `three/lights/LightManager.spec.js`

#### 测试用例

| 用例ID | 测试用例名称 | 测试内容 | 预期结果 | 优先级 |
|--------|-------------|----------|----------|--------|
| LM001 | 创建灯光管理器 | 测试LightManager构造函数 | 创建成功，灯光列表初始化 | P0 |
| LM002 | 创建环境光 | 测试createAmbientLight方法 | 环境光创建成功 | P0 |
| LM003 | 创建平行光 | 测试createDirectionalLight方法 | 平行光创建成功 | P0 |
| LM004 | 创建聚光灯 | 测试createSpotLight方法 | 聚光灯创建成功 | P0 |
| LM005 | 创建点光源 | 测试createPointLight方法 | 点光源创建成功 | P0 |
| LM006 | 添加灯光到场景 | 测试addLightToScene方法 | 灯光成功添加到场景 | P0 |
| LM007 | 从场景移除灯光 | 测试removeLightFromScene方法 | 灯光成功从场景移除 | P0 |
| LM008 | 更新灯光 | 测试updateLight方法 | 灯光属性更新成功 | P0 |
| LM009 | 获取灯光列表 | 测试getLights方法 | 返回正确的灯光列表 | P1 |
| LM010 | 获取指定灯光 | 测试getLight方法 | 返回指定的灯光 | P1 |
| LM011 | 销毁灯光管理器 | 测试destroy方法 | 所有灯光资源正确释放 | P0 |
| LM012 | 灯光数量控制 | 测试灯光数量限制 | 超出限制时抛出错误 | P1 |

#### 测试代码示例
```javascript
describe('LightManager', () => {
  let manager;
  let scene;

  beforeEach(() => {
    scene = new THREE.Scene();
    manager = new LightManager(scene);
  });

  afterEach(() => {
    if (manager) {
      manager.destroy();
    }
  });

  describe('createAmbientLight', () => {
    it('LM002: should create ambient light with correct properties', () => {
      const config = {
        color: 0xfffff0,
        intensity: 0.8
      };
      const light = manager.createAmbientLight(config);

      expect(light).toBeInstanceOf(THREE.AmbientLight);
      expect(light.color.getHex()).toBe(0xfffff0);
      expect(light.intensity).toBe(0.8);
    });
  });

  describe('createSpotLight', () => {
    it('LM004: should create spot light and add to scene', () => {
      const config = {
        color: 0xffffff,
        intensity: 1.0,
        position: { x: 0, y: 10, z: 0 }
      };
      const light = manager.createSpotLight('spot1', config);

      expect(light).toBeInstanceOf(THREE.SpotLight);
      expect(scene.children).toContain(light);
    });
  });

  describe('destroy', () => {
    it('LM011: should dispose all lights', () => {
      manager.createAmbientLight({ color: 0xffffff, intensity: 0.8 });
      manager.createSpotLight('spot1', { color: 0xffffff, intensity: 1.0 });
      manager.destroy();

      expect(scene.children.length).toBe(0);
    });
  });
});
```

---

## 六、Vue组件测试

### 6.1 ThreeDExhibition组件测试

#### 测试文件: `components/3d/ThreeDExhibition.spec.js`

#### 测试用例

| 用例ID | 测试用例名称 | 测试内容 | 预期结果 | 优先级 |
|--------|-------------|----------|----------|--------|
| V001 | 组件渲染 | 测试组件是否正确渲染 | 组件渲染成功 | P0 |
| V002 | 加载状态显示 | 测试loading状态 | 显示加载页面 | P0 |
| V003 | 开始按钮显示 | 测试start按钮 | 显示开始按钮 | P0 |
| V004 | 点击开始按钮 | 测试startExperience方法 | 进入3D展厅 | P0 |
| V005 | 展厅切换 | 测试switchHall方法 | 展厅切换成功 | P0 |
| V006 | 展厅导航显示 | 测试展厅导航栏 | 显示正确的展厅列表 | P0 |
| V007 | 展厅信息显示 | 测试展厅信息面板 | 显示当前展厅信息 | P0 |
| V008 | 操作提示显示 | 测试操作提示 | 显示操作说明 | P0 |
| V009 | 展品交互 | 测试画框点击 | 显示展品详情弹窗 | P0 |
| V010 | 关闭弹窗 | 测试closeArtwork方法 | 弹窗关闭成功 | P0 |
| V011 | 窗口调整 | 测试handleResize方法 | 视口正确调整 | P0 |
| V012 | 组件销毁 | 测试beforeDestroy钩子 | 资源正确释放 | P0 |

#### 测试代码示例
```javascript
import { mount } from '@vue/test-utils';
import ThreeDExhibition from '@/components/3d/ThreeDExhibition.vue';

describe('ThreeDExhibition', () => {
  let wrapper;

  beforeEach(() => {
    wrapper = mount(ThreeDExhibition, {
      attachTo: document.body
    });
  });

  afterEach(() => {
    if (wrapper) {
      wrapper.unmount();
    }
  });

  describe('Rendering', () => {
    it('V001: should render correctly', () => {
      expect(wrapper.find('.exhibition-container').exists()).toBe(true);
    });

    it('V002: should show loading overlay when loading', async () => {
      await wrapper.setData({ loading: true });
      expect(wrapper.find('.loading-overlay').exists()).toBe(true);
    });

    it('V003: should show start button when not loading and not locked', async () => {
      await wrapper.setData({ loading: false, isLocked: false });
      expect(wrapper.find('.start-btn').exists()).toBe(true);
    });
  });

  describe('Interactions', () => {
    it('V004: should start experience when button clicked', async () => {
      await wrapper.setData({ loading: false, isLocked: false });
      await wrapper.find('.start-btn').trigger('click');
      expect(wrapper.vm.isLocked).toBe(true);
    });

    it('V005: should switch hall when hall tab clicked', async () => {
      await wrapper.setData({ isLocked: true });
      const hallTabs = wrapper.findAll('.hall-tab');
      if (hallTabs.length > 0) {
        await hallTabs[1].trigger('click');
        expect(wrapper.vm.currentHallId).not.toBe('entrance');
      }
    });
  });

  describe('Lifecycle', () => {
    it('V012: should cleanup resources when destroyed', () => {
      const destroySpy = jest.spyOn(wrapper.vm, 'cleanup');
      wrapper.unmount();
      expect(destroySpy).toHaveBeenCalled();
    });
  });
});
```

---

### 6.2 NavigationToolbar组件测试

#### 测试文件: `components/3d/NavigationToolbar.spec.js`

#### 测试用例

| 用例ID | 测试用例名称 | 测试内容 | 预期结果 | 优先级 |
|--------|-------------|----------|----------|--------|
| NV001 | 组件渲染 | 测试组件是否正确渲染 | 组件渲染成功 | P0 |
| NV002 | 显示当前展厅 | 测试当前展厅高亮 | 当前展厅正确高亮 | P0 |
| NV003 | 切换展厅 | 测试展厅切换功能 | 展厅切换成功 | P0 |
| NV004 | 模式切换 | 测试导航模式切换 | 模式切换成功 | P0 |
| NV005 | 显示小地图 | 测试小地图显示 | 小地图正确显示 | P1 |
| NV006 | 点击事件 | 测试点击事件 | 事件正确触发 | P0 |

#### 测试代码示例
```javascript
import { mount } from '@vue/test-utils';
import NavigationToolbar from '@/components/3d/NavigationToolbar.vue';

describe('NavigationToolbar', () => {
  let wrapper;

  beforeEach(() => {
    wrapper = mount(NavigationToolbar, {
      propsData: {
        currentHall: 'early',
        halls: [
          { id: 'entrance', name: '入口大厅' },
          { id: 'early', name: '早期展厅' },
          { id: 'middle', name: '盛期展厅' },
          { id: 'late', name: '晚期展厅' }
        ]
      }
    });
  });

  afterEach(() => {
    if (wrapper) {
      wrapper.unmount();
    }
  });

  describe('Rendering', () => {
    it('NV001: should render correctly', () => {
      expect(wrapper.find('.hall-navigation').exists()).toBe(true);
    });

    it('NV002: should highlight current hall', () => {
      const activeTab = wrapper.find('.hall-tab.active');
      expect(activeTab.text()).toContain('早期展厅');
    });
  });

  describe('Interactions', () => {
    it('NV003: should emit hall-change event when tab clicked', async () => {
      const hallTabs = wrapper.findAll('.hall-tab');
      await hallTabs[2].trigger('click');

      expect(wrapper.emitted('hall-change')).toBeTruthy();
      expect(wrapper.emitted('hall-change')[0]).toEqual(['middle']);
    });
  });
});
```

---

## 七、工具函数测试

### 7.1 通用工具函数测试

#### 测试文件: `utils/format.spec.js`

#### 测试用例

| 用例ID | 测试用例名称 | 测试内容 | 预期结果 | 优先级 |
|--------|-------------|----------|----------|--------|
| U001 | 格式化日期 | 测试formatDate函数 | 返回格式化的日期字符串 | P0 |
| U002 | 格式化数字 | 测试formatNumber函数 | 返回格式化的数字字符串 | P0 |
| U003 | 格式化文件大小 | 测试formatFileSize函数 | 返回格式化的文件大小 | P1 |
| U004 | 截断字符串 | 测试truncateString函数 | 返回截断后的字符串 | P1 |
| U005 | 生成唯一ID | 测试generateId函数 | 返回唯一的ID | P0 |
| U006 | 深度克隆对象 | 测试deepClone函数 | 返回对象的深拷贝 | P0 |
| U007 | 合并对象 | 测试mergeObjects函数 | 返回合并后的对象 | P0 |
| U008 | 防抖函数 | 测试debounce函数 | 函数正确防抖 | P1 |
| U009 | 节流函数 | 测试throttle函数 | 函数正确节流 | P1 |
| U010 | 判断空值 | 测试isEmpty函数 | 正确判断空值 | P0 |

#### 测试代码示例
```javascript
describe('Format Utils', () => {
  describe('formatDate', () => {
    it('U001: should format date correctly', () => {
      const date = new Date('2026-02-23');
      const result = formatDate(date, 'YYYY-MM-DD');
      expect(result).toBe('2026-02-23');
    });

    it('U001: should handle invalid date', () => {
      const result = formatDate(null);
      expect(result).toBe('');
    });
  });

  describe('generateId', () => {
    it('U005: should generate unique ID', () => {
      const id1 = generateId();
      const id2 = generateId();
      expect(id1).not.toBe(id2);
    });
  });

  describe('deepClone', () => {
    it('U006: should create deep copy of object', () => {
      const obj = { a: 1, b: { c: 2 } };
      const cloned = deepClone(obj);

      expect(cloned).toEqual(obj);
      expect(cloned).not.toBe(obj);
      expect(cloned.b).not.toBe(obj.b);
    });
  });
});
```

---

## 八、集成测试用例

### 8.1 展厅切换集成测试

#### 测试文件: `tests/integration/exhibition.spec.js`

#### 测试用例

| 用例ID | 测试用例名称 | 测试内容 | 预期结果 | 优先级 |
|--------|-------------|----------|----------|--------|
| I001 | 完整观展路线 | 测试入口→早期→盛期→晚期→尾厅 | 完整路线无错误 | P0 |
| I002 | 展厅来回切换 | 测试任意展厅切换 | 切换流畅无错误 | P0 |
| I003 | 快速切换展厅 | 测试快速连续切换 | 资源正确释放 | P0 |
| I004 | 展品交互流程 | 测试点击展品→查看详情→关闭 | 完整流程无错误 | P0 |
| I005 | 导航系统切换 | 测试三种导航模式切换 | 切换流畅无错误 | P1 |
| I006 | 窗口调整测试 | 测试各种窗口尺寸 | 显示正常无错误 | P0 |
| I007 | 性能测试 | 测试长时间运行 | 性能稳定无内存泄漏 | P0 |

#### 测试代码示例
```javascript
describe('Exhibition Integration', () => {
  let exhibition;

  beforeEach(async () => {
    exhibition = new Exhibition();
    await exhibition.initialize();
  });

  afterEach(async () => {
    if (exhibition) {
      await exhibition.destroy();
    }
  });

  describe('Complete Tour', () => {
    it('I001: should complete full exhibition tour without errors', async () => {
      await exhibition.switchHall('entrance');
      expect(exhibition.currentHallId).toBe('entrance');

      await exhibition.switchHall('early');
      expect(exhibition.currentHallId).toBe('early');

      await exhibition.switchHall('middle');
      expect(exhibition.currentHallId).toBe('middle');

      await exhibition.switchHall('late');
      expect(exhibition.currentHallId).toBe('late');

      await exhibition.switchHall('closing');
      expect(exhibition.currentHallId).toBe('closing');
    }, 30000);
  });

  describe('Performance', () => {
    it('I007: should run without memory leaks', async () => {
      const initialMemory = performance.memory?.usedJSHeapSize;

      // 模拟长时间运行
      for (let i = 0; i < 100; i++) {
        await exhibition.switchHall('early');
        await exhibition.switchHall('middle');
        await exhibition.switchHall('late');
        await exhibition.switchHall('entrance');
      }

      const finalMemory = performance.memory?.usedJSHeapSize;
      const memoryIncrease = finalMemory - initialMemory;

      // 内存增长不应超过50MB
      expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024);
    }, 60000);
  });
});
```

---

## 九、测试执行计划

### 9.1 测试执行流程

#### 执行步骤
1. **环境准备**
   - 安装依赖
   - 配置测试环境
   - 准备测试数据

2. **单元测试**
   - 执行3D工具函数测试
   - 执行场景管理器测试
   - 执行材质管理器测试
   - 执行灯光管理器测试
   - 执行Vue组件测试
   - 执行工具函数测试

3. **集成测试**
   - 执行展厅切换测试
   - 执行交互流程测试
   - 执行性能测试

4. **测试报告**
   - 生成测试报告
   - 分析测试结果
   - 提出改进建议

### 9.2 测试执行命令

```bash
# 安装测试依赖
npm install --save-dev jest @vue/test-utils @vue/vue3-jest babel-jest

# 运行所有测试
npm run test

# 运行单元测试
npm run test:unit

# 运行集成测试
npm run test:integration

# 运行特定测试文件
npm run test -- path/to/test.spec.js

# 生成测试覆盖率报告
npm run test:coverage

# 监听模式
npm run test:watch
```

---

## 十、测试结果报告

### 10.1 测试结果模板

```markdown
# 单元测试执行报告

## 测试概览
- 测试日期: 2026-02-23
- 测试执行人: 开发SubAgent
- 测试环境: 本地开发环境

## 测试统计
- 总测试用例数: 100
- 通过用例数: 95
- 失败用例数: 3
- 跳过用例数: 2
- 通过率: 95%

## 覆盖率统计
- 语句覆盖率: 75%
- 分支覆盖率: 65%
- 函数覆盖率: 82%
- 行覆盖率: 73%

## 失败用例详情
### 用例1: G005 - 计算矩形对角线长度
- 失败原因: 边界条件处理错误
- 错误信息: Expected 14.14, got 14.1421
- 修复状态: 待修复

### 用例2: S015 - 初始化失败处理
- 失败原因: 异常处理逻辑错误
- 错误信息: Timeout exceeded
- 修复状态: 已修复

### 用例3: I003 - 快速切换展厅
- 失败原因: 资源释放不完整
- 错误信息: Memory leak detected
- 修复状态: 修复中

## 改进建议
1. 增加边界条件测试
2. 优化资源释放逻辑
3. 增加性能测试用例

## 下一步计划
1. 修复失败用例
2. 增加测试覆盖率
3. 持续集成测试
```

---

## 十一、总结

本单元测试用例清单详细列出了黄宾虹数字艺术展3D展厅项目的所有测试用例，包括3D工具函数测试、场景管理器测试、材质管理器测试、灯光管理器测试、Vue组件测试、工具函数测试和集成测试，共计100+个测试用例。

通过执行这些测试用例，可以确保代码质量、发现潜在Bug、支持代码重构，最终交付一个高质量、稳定可靠的3D数字展厅应用。

---

**附录：参考资料**
- Jest官方文档: https://jestjs.io/
- Vue Test Utils文档: https://test-utils.vuejs.org/
- Three.js测试最佳实践: https://threejs.org/docs/