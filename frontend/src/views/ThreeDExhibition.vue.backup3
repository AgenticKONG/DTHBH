<template>
  <div class="corridor-container">
    <!-- ç¾åŒ–åŠ è½½é¡µé¢ -->
    <div class="loading-overlay" v-if="loading">
      <div class="loading-content">
        <div class="loader">
          <div class="loader-spinner"></div>
          <div class="loader-text">åŠ è½½ä¸­...</div>
        </div>
        <div class="loading-tip">
          <p>ğŸ¨ é»„å®¾è™¹è‰ºæœ¯é•¿å»Š</p>
          <p>ä½¿ç”¨ W/S æˆ– â†‘/â†“ é”®å‰åç§»åŠ¨</p>
          <p>é¼ æ ‡å·¦é”®æ‹–åŠ¨å¯æ—‹è½¬è§†è§’</p>
        </div>
      </div>
    </div>

    <!-- æ ‡ç­¾å…³é—­æŒ‰é’® -->
    <div v-if="activeIntro" class="intro-close-btn" @click="closeIntro">
      Ã—
    </div>

    <div ref="sceneContainer" id="scene-container"></div>

    <!-- å±•å…å¯¼èˆªæ  -->
    <div class="hall-nav">
      <div
        v-for="hall in allHalls"
        :key="hall.id"
        :class="['hall-nav-item', { active: currentHallId === hall.id }]"
        @click="switchHall(hall.id)"
      >
        <div class="hall-nav-name">{{ hall.name }}</div>
        <div class="hall-nav-desc">{{ hall.description }}</div>
      </div>
    </div>

    <!-- å½“å‰å±•å…ä¿¡æ¯ -->
    <div class="hall-info" v-if="currentHall">
      <div class="hall-info-title">{{ currentHall.name }}</div>
      <div class="hall-info-desc">{{ currentHall.description }}</div>
    </div>

    <!-- æ“ä½œæç¤º -->
    <div class="controls-hint">
      <div class="hint-item">W/S æˆ– â†‘/â†“ï¼šå‰åç§»åŠ¨</div>
      <div class="hint-item">é¼ æ ‡æ‹–åŠ¨ï¼šæ—‹è½¬è§†è§’</div>
    </div>
  </div>
</template>

<script>
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { CSS2DRenderer } from 'three/examples/jsm/renderers/CSS2DRenderer';
import createPersonIntroduction from './charactor.js';
import { IntroManager } from './charactor.js';
import { getHallConfig, getAllHalls } from '../config/exhibitionHalls.js';

export default {
  name: 'CorridorScene',
  data() {
    return {
      loading: true,
      currentHallId: 'entrance', // å½“å‰å±•å…ID
      moveSpeed: 0.15,
      keys: { w: false, s: false, ArrowUp: false, ArrowDown: false },
      paintingParams: {
        spacing: 12,
        offsetY: 4.5,
        thickness: 0.05
      },
      paintingSizes: [],
      animationId: null,
      activeIntro: null,
      loadingProgress: 0,
      totalResources: 0,
      loadedResources: 0
    };
  },

  // Three.js å¯¹è±¡ä½œä¸ºç»„ä»¶å±æ€§ï¼Œé¿å… Vue å“åº”å¼åŒ…è£…
  scene: null,
  camera: null,
  renderer: null,
  controls: null,
  labelRenderer: null,
  introManager: null,

  computed: {
    // å½“å‰å±•å…é…ç½®
    currentHall() {
      return getHallConfig(this.currentHallId);
    },
    // æ‰€æœ‰å±•å…åˆ—è¡¨
    allHalls() {
      return getAllHalls();
    },
    // å½“å‰å±•å…çš„ç©ºé—´å‚æ•°
    spaceParams() {
      return this.currentHall?.space || { length: 200, width: 14, height: 14, wallThickness: 0.1 };
    },
    // å½“å‰å±•å…çš„å±•å“
    hallPaintings() {
      return this.currentHall?.paintings || [];
    }
  },
  mounted() {
    this.initScene();
    this.initListeners();
    
    // æ¨¡æ‹ŸåŠ è½½è¿›åº¦
    this.simulateLoading();
  },
  beforeUnmount() {
    this.cleanup();
  },
  methods: {
    simulateLoading() {
      const interval = setInterval(() => {
        this.loadingProgress += 5;
        if (this.loadingProgress >= 100) {
          clearInterval(interval);
          setTimeout(() => {
            this.loading = false;
            this.animate();
          }, 500);
        }
      }, 100);
    },

    initScene() {
      // 1. åˆå§‹åŒ–åŸºç¡€ç»„ä»¶
      this.scene = new THREE.Scene();
      // ä½¿ç”¨å½“å‰å±•å…çš„èƒŒæ™¯è‰²ï¼Œé»˜è®¤ä¸º0xF0E6D2
      this.scene.background = new THREE.Color(0xF0E6D2);
      this.initInteraction();

      // é€è§†ç›¸æœº - ä½¿ç”¨å½“å‰å±•å…é…ç½®
      this.camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const camPos = this.currentHall?.camera?.position || { x: 0, y: 10.6, z: 0 };
      const camTarget = this.currentHall?.camera?.target || { x: 0, y: 0, z: 100 };
      this.camera.position.set(camPos.x, camPos.y, camPos.z);
      this.camera.lookAt(camTarget.x, camTarget.y, camTarget.z);

      // æ¸²æŸ“å™¨
      this.renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true
      });
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      this.$refs.sceneContainer.appendChild(this.renderer.domElement);

      // åˆ›å»ºå±•å…ç»“æ„ï¼ˆæ ¹æ®å½“å‰å±•å…é…ç½®ï¼‰
      this.createHall();

      // æ·»åŠ å…‰ç…§ç³»ç»Ÿï¼ˆæ ¹æ®å½“å‰å±•å…é…ç½®ï¼‰
      this.addLighting();

      // åˆå§‹åŒ–CSS2DRenderer
      this.initCSS2DRenderer();

      // åˆ›å»ºäººç‰©ä»‹ç»
      this.createPersonIntros();

      // åŠ è½½ç”»ä½œ
      this.loadAndCreatePaintings();

      // åˆ›å»ºå±•å…å…¥å£æ ‡è®°
      this.createEntranceMarkers();

      // æ·»åŠ ç›¸æœºæ§åˆ¶å™¨
      this.initControls();
    },

    createHall() {
      const materials = this.currentHall?.materials || {
        wall: { color: 0xFfF5F0, roughness: 0.6, metalness: 0.1 },
        floor: { color: 0xF0E6D2, roughness: 0.2, metalness: 0.7, opacity: 0.9, transparent: true },
        ceiling: { color: 0xFfF5F0, roughness: 0.8, metalness: 0.5 }
      };

      const wallMaterial = new THREE.MeshStandardMaterial(materials.wall);
      const floorMaterial = new THREE.MeshStandardMaterial(materials.floor);
      const ceilMaterial = new THREE.MeshStandardMaterial(materials.ceiling);

      // å·¦ä¾§å¢™ä½“
      const leftWall = new THREE.Mesh(
        new THREE.BoxGeometry(this.spaceParams.wallThickness, this.spaceParams.height, this.spaceParams.length),
        wallMaterial
      );
      leftWall.position.set(
        -this.spaceParams.width / 2 + this.spaceParams.wallThickness / 2,
        this.spaceParams.height / 2,
        this.spaceParams.length / 2
      );
      leftWall.receiveShadow = true;
      leftWall.castShadow = true;
      this.scene.add(leftWall);

      // å³ä¾§å¢™ä½“
      const rightWall = new THREE.Mesh(
        new THREE.BoxGeometry(this.spaceParams.wallThickness, this.spaceParams.height, this.spaceParams.length),
        wallMaterial
      );
      rightWall.position.set(
        this.spaceParams.width / 2 - this.spaceParams.wallThickness / 2,
        this.spaceParams.height / 2,
        this.spaceParams.length / 2
      );
      rightWall.receiveShadow = true;
      rightWall.castShadow = true;
      this.scene.add(rightWall);

      // åœ°é¢
      const floor = new THREE.Mesh(
        new THREE.BoxGeometry(this.spaceParams.width, this.spaceParams.wallThickness, this.spaceParams.length),
        floorMaterial
      );
      floor.position.set(0, this.spaceParams.wallThickness / 2, this.spaceParams.length / 2);
      floor.receiveShadow = true;
      this.scene.add(floor);

      // å¤©èŠ±æ¿
      const ceiling = new THREE.Mesh(
        new THREE.BoxGeometry(this.spaceParams.width, this.spaceParams.wallThickness, this.spaceParams.length),
        ceilMaterial
      );
      ceiling.position.x = 0;
      ceiling.position.y = this.spaceParams.height - (this.spaceParams.wallThickness / 2);
      ceiling.position.z = this.spaceParams.length / 2;
      ceiling.receiveShadow = true;
      this.scene.add(ceiling);

      // å±•å…å°½å¤´
      const endWall = new THREE.Mesh(
        new THREE.BoxGeometry(this.spaceParams.width, this.spaceParams.height, this.spaceParams.wallThickness),
        wallMaterial
      );
      endWall.position.set(0, this.spaceParams.height / 2, this.spaceParams.length - this.spaceParams.wallThickness / 2);
      endWall.receiveShadow = true;
      this.scene.add(endWall);
    },

    addLighting() {
      const lightingConfig = this.currentHall?.lighting || {
        ambient: { color: 0xfffff0, intensity: 0.8 },
        directional: []
      };

      // ç¯å¢ƒå…‰
      const ambientLight = new THREE.AmbientLight(
        lightingConfig.ambient.color,
        lightingConfig.ambient.intensity
      );
      this.scene.add(ambientLight);

      // æ–¹å‘å…‰
      lightingConfig.directional.forEach(lightConfig => {
        const dirLight = new THREE.DirectionalLight(
          lightConfig.color,
          lightConfig.intensity
        );
        dirLight.position.set(
          lightConfig.position.x,
          lightConfig.position.y,
          lightConfig.position.z
        );
        dirLight.target.position.set(0, this.spaceParams.height / 2, this.spaceParams.length / 2);
        this.scene.add(dirLight.target);
        dirLight.castShadow = false;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        this.scene.add(dirLight);
      });
    },

    initCSS2DRenderer() {
      this.labelRenderer = new CSS2DRenderer();
      this.labelRenderer.setSize(window.innerWidth, window.innerHeight);
      this.labelRenderer.domElement.style.position = 'absolute';
      this.labelRenderer.domElement.style.top = '0';
      this.labelRenderer.domElement.style.left = '0';
      this.labelRenderer.domElement.style.pointerEvents = 'none';
      this.labelRenderer.domElement.id = 'css2d-renderer';
      document.body.appendChild(this.labelRenderer.domElement);
    },

    createPersonIntros() {
      this.introManager = new IntroManager(this.camera);
      
      // ä¿®æ”¹IntroManagerä»¥æ”¯æŒå…³é—­åŠŸèƒ½
      const originalShowIntro = this.introManager.showIntro.bind(this.introManager);
      const originalHideIntro = this.introManager.hideIntro.bind(this.introManager);
      
      this.introManager.showIntro = (intro) => {
        originalShowIntro(intro);
        this.activeIntro = intro;

        // æ·»åŠ å…³é—­æŒ‰é’®åˆ°æ–‡å­—å…ƒç´ 
        try {
          if (intro.textElement && intro.textElement.element) {
            const element = intro.textElement.element;

            // æ£€æŸ¥æ˜¯å¦å·²æœ‰å…³é—­æŒ‰é’®
            if (!element.querySelector('.intro-close-button')) {
              const closeBtn = document.createElement('div');
              closeBtn.className = 'intro-close-button';   // ç»Ÿä¸€ç±»å
              closeBtn.innerHTML = 'Ã—';
              closeBtn.style.cssText = `
                position: absolute;
                top: 10px;
                right: 10px;
                width: 30px;
                height: 30px;
                background: rgba(139, 69, 19, 0.9);
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                cursor: pointer;
                z-index: 1000;
                pointer-events: auto;   /* å…³é”®ï¼šå…è®¸ç‚¹å‡» */
                transition: all 0.3s;
              `;
              closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();     // é˜²æ­¢å†’æ³¡
                this.closeIntro();
              });
              closeBtn.addEventListener('mouseenter', () => {
                closeBtn.style.background = 'rgba(139, 69, 19, 1)';
                closeBtn.style.transform = 'scale(1.1)';
              });
              closeBtn.addEventListener('mouseleave', () => {
                closeBtn.style.background = 'rgba(139, 69, 19, 0.9)';
                closeBtn.style.transform = 'scale(1)';
              });
              element.style.position = 'relative';
              element.appendChild(closeBtn);
            }
          }
        } catch (error) {
          console.error('æ·»åŠ å…³é—­æŒ‰é’®æ—¶å‡ºé”™:', error);
        }
      };
      
      this.introManager.hideIntro = (intro) => {
        originalHideIntro(intro);
        if (this.activeIntro === intro) {
          this.activeIntro = null;
        }
      };

// 1. ç™½å®¾è™¹é˜¶æ®µï¼ˆ1865-1930 å·¦å³ï¼‰
const introPanel = createPersonIntroduction(this.scene, {
  position: new THREE.Vector3(0, 5, 10),
  corridorLength: 80,
  corridorHeight: 12,
  panelWidth: 7,
  panelHeight: 8,
  content: {
    name: "ç™½å®¾è™¹",
    lifespan: "1865-1930",
    title: "æ—©æœŸÂ·ç™½å®¾è™¹",
    honor: "â€œç™½å®¾è™¹â€æ—¶æœŸ",
    detail: "ä»¥ç–æ·¡æ¸…é€¸çš„â€œç™½å®¾è™¹â€é¢è²Œè‘—ç§°ï¼Œå®—æ³•æ–°å®‰ç”»æ´¾ï¼Œç”¨ç¬”è½»çµã€è®¾è‰²æ·¡é›…ï¼Œç”»é¢ç•™ç™½å¤šï¼Œå°šæœªå½¢æˆåæ¥æµ‘åšåæ»‹çš„é£æ ¼ã€‚"
  }
});
this.introManager.addIntro(introPanel);

// 2. é»„å®¾è™¹é˜¶æ®µï¼ˆ1930-1948 å·¦å³ï¼‰
const introPanel2 = createPersonIntroduction(this.scene, {
  position: new THREE.Vector3(0, 5, 40),
  corridorLength: 80,
  corridorHeight: 12,
  panelWidth: 7,
  panelHeight: 8,
  content: {
    name: "é»„å®¾è™¹",
    lifespan: "1930-1948",
    title: "ç››æœŸÂ·é»„å®¾è™¹",
    honor: "â€œé»„å®¾è™¹â€æ—¶æœŸ",
    detail: "ç”±â€œç™½â€å…¥â€œé»„â€ï¼Œç§¯å¢¨ã€ç ´å¢¨ã€æ¸å¢¨å¹¶ç”¨ï¼Œç”»é¢è¶‹äºè‹æ¶¦æµ‘åšï¼›æå‡ºâ€œäº”ç¬”ä¸ƒå¢¨â€è¯´ï¼Œå±±æ°´æµ‘åšåæ»‹ï¼Œå½¢æˆæ ‡å¿—æ€§çš„â€œé»„å®¾è™¹è°ƒâ€ã€‚"
  }
});
this.introManager.addIntro(introPanel2);

// 3. é»‘å®¾è™¹é˜¶æ®µï¼ˆ1948-1955 æ™šå¹´ï¼‰
const introPanel3 = createPersonIntroduction(this.scene, {
  position: new THREE.Vector3(0, 5, 80),
  corridorLength: 80,
  corridorHeight: 12,
  panelWidth: 7,
  panelHeight: 8,
  content: {
    name: "é»‘å®¾è™¹",
    lifespan: "1948-1955",
    title: "æ™šæœŸÂ·é»‘å®¾è™¹",
    honor: "â€œé»‘å®¾è™¹â€æ—¶æœŸ",
    detail: "ä»¥æµ“å¢¨ã€ç„¦å¢¨ã€å®¿å¢¨å±‚å±‚ç§¯æŸ“ï¼Œç”»é¢é»‘ä¸­é€äº®ï¼Œæ‰€è°“â€œé»‘å›¢å›¢é‡Œå¢¨å›¢å›¢â€ï¼›ç”¨ç¬”æ›´è¶‹è‡ªç”±ï¼Œå½¢æˆâ€œæµ‘åšåæ»‹ã€é»‘å¯†åšé‡â€çš„ç»ˆæé£æ ¼ã€‚"
  }
});
this.introManager.addIntro(introPanel3);
      
    },

createAdaptivePainting(texture, index, isLeft = true) {
  const image = texture.image;
  const imgWidth = image.width;
  const imgHeight = image.height;

  const maxWidth = 4.0;
  const maxHeight = 5.0;

  let width, height;
  const aspectRatio = imgWidth / imgHeight;

  if (aspectRatio > 1) {
    width = Math.min(maxWidth, imgWidth / 200);
    height = width / aspectRatio;
    if (height > maxHeight) {
      height = maxHeight;
      width = height * aspectRatio;
    }
  } else {
    height = Math.min(maxHeight, imgHeight / 200);
    width = height * aspectRatio;
    if (width > maxWidth) {
      width = maxWidth;
      height = width / aspectRatio;
    }
  }

  this.paintingSizes[index] = { width, height, aspectRatio };

  const paintingMaterial = new THREE.MeshStandardMaterial({
    map: texture,
    side: THREE.DoubleSide,
    roughness: 0.8,
    metalness: 0.2
  });

  const frameMaterial = new THREE.MeshStandardMaterial({
    color: 0x8b4513,
    roughness: 0.4,
    metalness: 0.6
  });

  const painting = new THREE.Mesh(
    new THREE.PlaneGeometry(width, height),
    paintingMaterial
  );

  const frame = new THREE.Mesh(
    new THREE.BoxGeometry(
      width + 0.12,
      height + 0.12,
      this.paintingParams.thickness
    ),
    frameMaterial
  );

  const posZ = this.paintingParams.spacing * (index + 1);

  if (isLeft) {
    painting.position.set(
      -this.corridorParams.width / 2 + 0.5,
      this.paintingParams.offsetY + height / 2,
      posZ
    );
    painting.rotation.y = Math.PI / 2;

    frame.position.copy(painting.position);
    frame.position.x = painting.position.x - this.paintingParams.thickness / 2 - 0.01;
    frame.rotation.y = painting.rotation.y;
  } else {
    painting.position.set(
      this.corridorParams.width / 2 - 0.5,
      this.paintingParams.offsetY + height / 2,
      posZ
    );
    painting.rotation.y = -Math.PI / 2;

    frame.position.copy(painting.position);
    frame.position.x = painting.position.x + this.paintingParams.thickness / 2 + 0.01;
    frame.rotation.y = painting.rotation.y;
  }

  painting.castShadow = true;
  painting.receiveShadow = true;
  frame.castShadow = true;

  // âœ… å…³é”®ï¼šæŠŠ id æŒ‚åˆ° mesh ä¸Š
  painting.userData.id = this.paintingImages[index].id;

  this.scene.add(painting);
  this.scene.add(frame);

  return { painting, frame, width, height };
},
loadAndCreatePaintings() {
  const textureLoader = new THREE.TextureLoader();
  let loadCount = 0;
  const totalImages = this.paintingImages.length * 2; // âœ… ä¿®å¤ï¼šåŸæ¥æ˜¯ .url.length

  this.paintingImages.forEach((image, index) => {
    const imagePath = image.url;
    textureLoader.load(
      imagePath,
      (texture) => {
        texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy();
        this.createAdaptivePainting(texture, index, true);
        this.createAdaptivePainting(texture, index, false);
        loadCount += 2;

        if (loadCount === totalImages) {
          console.log('æ‰€æœ‰ç”»ä½œåŠ è½½å®Œæˆ');
        }
      },
      undefined,
      (error) => {
        console.error('å›¾ç‰‡åŠ è½½å¤±è´¥:', error);
      }
    );
  });
},
initInteraction() {
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();

  const onPointerDown = (event) => {
    const x = event.clientX ?? event.touches?.[0]?.clientX;
    const y = event.clientY ?? event.touches?.[0]?.clientY;

    if (x === undefined || y === undefined) return;

    pointer.x = (x / window.innerWidth) * 2 - 1;
    pointer.y = -(y / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(pointer, this.camera);
    const intersects = raycaster.intersectObjects(this.scene.children, false);

    for (let i = 0; i < intersects.length; i++) {
      const obj = intersects[i].object;
      if (obj.userData.id !== undefined) {
        window.location.href = `/work?id=${obj.userData.id}`;
        break;
      }
    }
  };

  window.addEventListener('click', onPointerDown);
  window.addEventListener('touchstart', onPointerDown);
},
    initControls() {
      this.controls = new OrbitControls(this.camera, this.renderer.domElement);
      this.controls.enableDamping = true;
      this.controls.dampingFactor = 0.05;
      this.controls.enablePan = true;
      this.controls.enableZoom = false;
      this.controls.enableRotate = true;
      this.controls.minPolarAngle = Math.PI / 2;
      this.controls.maxPolarAngle = Math.PI / 2;
      this.controls.minAzimuthAngle = -Infinity;
      this.controls.maxAzimuthAngle = Infinity;
    },

    initListeners() {
      document.addEventListener('keydown', this.handleKeyDown);
      document.addEventListener('keyup', this.handleKeyUp);
      window.addEventListener('resize', this.handleResize);
    },

    handleKeyDown(e) {
      const key = e.key;
      if (Object.prototype.hasOwnProperty.call(this.keys, key)) {
        this.keys[key] = true;
      }
    },

    handleKeyUp(e) {
      const key = e.key;
      if (Object.prototype.hasOwnProperty.call(this.keys, key)) {
        this.keys[key] = false;
      }
    },

    handleResize() {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.labelRenderer.setSize(window.innerWidth, window.innerHeight);
    },

    updateCameraPosition() {
      // ä¿®æ”¹äº†è¿™é‡Œ
      const direction = new THREE.Vector3();
      this.camera.getWorldDirection(direction);
      let directionZ=direction.z;
      if (directionZ<0) {
        directionZ=-1;
      }else{
        directionZ=1;
      }
      if (this.keys.w || this.keys.ArrowUp) {
        this.camera.position.z += this.moveSpeed*directionZ;
        this.camera.position.z = Math.min(this.camera.position.z, this.spaceParams.length - 5);
      }

      if (this.keys.s || this.keys.ArrowDown) {
        this.camera.position.z -= this.moveSpeed*directionZ;
        this.camera.position.z = Math.max(this.camera.position.z, 2);
      }

      const lookDirection = new THREE.Vector3(0, 0, 1);
      lookDirection.applyQuaternion(this.camera.quaternion);
      this.controls.target.copy(this.camera.position).add(lookDirection.multiplyScalar(-5));
    },

    /**
     * åˆ‡æ¢å±•å…
     * @param {string} hallId - å±•å…ID
     */
    switchHall(hallId) {
      if (!getHallConfig(hallId)) {
        console.error(`å±•å…ä¸å­˜åœ¨: ${hallId}`);
        return;
      }

      // æ¸…ç†å½“å‰å±•å…çš„3Då¯¹è±¡
      this.clearScene();

      // åˆ‡æ¢åˆ°æ–°å±•å…
      this.currentHallId = hallId;

      // é‡æ–°åˆå§‹åŒ–åœºæ™¯
      this.initScene();

      console.log(`å·²åˆ‡æ¢åˆ°å±•å…: ${this.currentHall.name}`);
    },

    /**
     * æ¸…ç†åœºæ™¯ä¸­çš„æ‰€æœ‰3Då¯¹è±¡
     */
    clearScene() {
      // ç§»é™¤åœºæ™¯ä¸­çš„æ‰€æœ‰meshå¯¹è±¡
      const objectsToRemove = [];
      this.scene.traverse((object) => {
        if (object.isMesh) {
          objectsToRemove.push(object);
        }
      });
      objectsToRemove.forEach(obj => {
        if (obj.geometry) obj.geometry.dispose();
        if (obj.material) {
          if (Array.isArray(obj.material)) {
            obj.material.forEach(mat => mat.dispose());
          } else {
            obj.material.dispose();
          }
        }
        this.scene.remove(obj);
      });

      // ç§»é™¤æ‰€æœ‰ç¯å…‰
      const lightsToRemove = [];
      this.scene.traverse((object) => {
        if (object.isLight) {
          lightsToRemove.push(object);
        }
      });
      lightsToRemove.forEach(light => {
        this.scene.remove(light);
      });

      // æ¸…ç†CSS2Dæ ‡ç­¾
      const css2dElement = document.getElementById('css2d-renderer');
      if (css2dElement && css2dElement.innerHTML) {
        css2dElement.innerHTML = '';
      }

      // é‡ç½®ç›¸æœºæ§åˆ¶å™¨
      if (this.controls) {
        this.controls.dispose();
      }

      // é‡ç½®introManager
      if (this.introManager) {
        this.introManager = null;
      }
    },

    /**
     * åˆ›å»ºå±•å…å…¥å£æ ‡è®°
     */
    createEntranceMarkers() {
      const markers = this.currentHall?.entranceMarkers || [];
      markers.forEach((marker) => {
        // åˆ›å»ºå…¥å£æ ‡è®°çš„è§†è§‰è¡¨ç¤º
        const markerGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const markerMaterial = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          emissive: 0xffd700,
          emissiveIntensity: 0.5
        });
        const markerMesh = new THREE.Mesh(markerGeometry, markerMaterial);
        markerMesh.position.set(
          marker.position.x,
          marker.position.y,
          marker.position.z
        );
        markerMesh.userData = {
          type: 'entrance_marker',
          targetHall: marker.targetHall,
          label: marker.label
        };
        this.scene.add(markerMesh);

        // æ·»åŠ å…‰æ™•æ•ˆæœ
        const glowGeometry = new THREE.SphereGeometry(0.7, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0xffd700,
          transparent: true,
          opacity: 0.3
        });
        const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
        glowMesh.position.copy(markerMesh.position);
        this.scene.add(glowMesh);
      });
    },

    closeIntro() {
      if (this.activeIntro && this.introManager) {
        this.introManager.hideIntro(this.activeIntro);
        this.activeIntro = null;
      }
    },

    animate() {
      this.animationId = requestAnimationFrame(this.animate);
      this.updateCameraPosition();
      this.controls.update();
      this.renderer.render(this.scene, this.camera);
      this.labelRenderer.render(this.scene, this.camera);
      
      if (this.introManager) {
        this.introManager.update();
      }
    },

    cleanup() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
      
      document.removeEventListener('keydown', this.handleKeyDown);
      document.removeEventListener('keyup', this.handleKeyUp);
      window.removeEventListener('resize', this.handleResize);
      
      if (this.renderer) {
        this.renderer.dispose();
      }
      
      const css2dElement = document.getElementById('css2d-renderer');
      if (css2dElement && css2dElement.parentNode) {
        css2dElement.parentNode.removeChild(css2dElement);
      }
    }
  }
};
</script>

<style scoped>
.corridor-container {
  position: relative;
  width: 100vw;
  height: 100vh;
  overflow: hidden;
}

/* ç¾åŒ–åŠ è½½é¡µé¢ */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: black;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 1;
  transition: opacity 0.5s ease;
}

.loading-overlay.fade-out {
  opacity: 0;
}

.loading-content {
  text-align: center;
  color: white;
  max-width: 500px;
  padding: 40px;
}

/* åŠ è½½åŠ¨ç”» */
.loader {
  margin-bottom: 40px;
}

.loader-spinner {
  width: 80px;
  height: 80px;
  margin: 0 auto 20px;
  border: 4px solid rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  border-top-color: #FfF5F0;
  animation: spin 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loader-text {
  font-size: 20px;
  color: #FfF5F0;
  margin-bottom: 10px;
  font-weight: bold;
}

/* è¿›åº¦æ¡ */
.progress-bar {
  width: 300px;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  margin: 20px auto;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #ffd700, #ff8c00);
  border-radius: 2px;
  width: 0%;
  transition: width 0.3s ease;
}

/* åŠ è½½æç¤º */
.loading-tip {
  background: rgba(255, 255, 255, 0.1);
  padding: 20px;
  border-radius: 10px;
  margin-top: 30px;
  backdrop-filter: blur(10px);
}

.loading-tip p {
  margin: 10px 0;
  font-size: 16px;
  color: rgba(255, 255, 255, 0.9);
}

.loading-tip p:first-child {
  font-size: 24px;
  color: #FfF5F0;
  font-weight: bold;
  margin-bottom: 15px;
}

/* å…¨å±€å…³é—­æŒ‰é’® */
.intro-close-btn {
  position: fixed;
  top: 20px;
  right: 20px;
  width: 40px;
  height: 40px;
  background: rgba(139, 69, 19, 0.9);
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
  cursor: pointer;
  z-index: 999;
  transition: all 0.3s;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.intro-close-btn:hover {
  background: rgba(139, 69, 19, 1);
  transform: scale(1.1);
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
}

/* æ“ä½œæç¤º */
.controls-hint {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 30px;
  background: rgba(0, 0, 0, 0.7);
  padding: 12px 24px;
  border-radius: 20px;
  backdrop-filter: blur(10px);
  z-index: 998;
}

/* å±•å…å¯¼èˆªæ  */
.hall-nav {
  position: fixed;
  left: 20px;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  gap: 12px;
  background: rgba(255, 255, 255, 0.95);
  padding: 16px;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(10px);
  z-index: 997;
}

.hall-nav-item {
  padding: 12px 16px;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.3s;
  border: 2px solid transparent;
}

.hall-nav-item:hover {
  background: rgba(139, 69, 19, 0.1);
  transform: translateX(5px);
}

.hall-nav-item.active {
  background: linear-gradient(135deg, rgba(139, 69, 19, 0.9), rgba(255, 215, 0, 0.9));
  color: white;
  border-color: rgba(255, 215, 0, 0.5);
  box-shadow: 0 2px 10px rgba(139, 69, 19, 0.3);
}

.hall-nav-name {
  font-size: 16px;
  font-weight: bold;
  margin-bottom: 4px;
}

.hall-nav-desc {
  font-size: 12px;
  opacity: 0.8;
}

/* å½“å‰å±•å…ä¿¡æ¯ */
.hall-info {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255, 255, 255, 0.95);
  padding: 16px 32px;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
  backdrop-filter: blur(10px);
  z-index: 997;
  text-align: center;
}

.hall-info-title {
  font-size: 20px;
  font-weight: bold;
  color: #8B4513;
  margin-bottom: 4px;
}

.hall-info-desc {
  font-size: 14px;
  color: #666;
}

.hint-item {
  color: rgba(255, 255, 255, 0.9);
  font-size: 14px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.hint-item::before {
  content: '';
  display: inline-block;
  width: 6px;
  height: 6px;
  background: #ffd700;
  border-radius: 50%;
}

#scene-container {
  width: 100%;
  height: 100%;
  outline: none;
}

/* å…¨å±€CSSç”¨äºCSS2Dæ ‡ç­¾ */
:deep(.person-intro) {
  position: relative !important;
  pointer-events: auto !important;
}

:deep(.intro-close-button) {
  position: absolute !important;
  top: 10px !important;
  right: 10px !important;
  width: 30px !important;
  height: 30px !important;
  background: rgba(139, 69, 19, 0.8) !important;
  color: white !important;
  border-radius: 50% !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  font-size: 24px !important;
  cursor: pointer !important;
  z-index: 1000 !important;
  transition: all 0.3s !important;
}

:deep(.intro-close-button:hover) {
  background: rgba(139, 69, 19, 1) !important;
  transform: scale(1.1) !important;
}
</style>
